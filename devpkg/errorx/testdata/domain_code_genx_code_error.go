// Package testdata GENERATED BY code_error DO NOT EDIT
package testdata

import (
	"fmt"

	"github.com/pkg/errors"
)

var domainCodeMessages = map[DomainCode]string{
	DOMAIN_CODE_UNDEFINED:  "[DOMAIN_NAME:0] undefined",
	DOMAIN_CODE__PARSE:     "[DOMAIN_NAME:1] parse failed",
	DOMAIN_CODE__HANDLE:    "[DOMAIN_NAME:2] handle failed",
	DOMAIN_CODE__PARAMETER: "[DOMAIN_NAME:3] invalid parameter",
}

func NewDomainCodeError(code DomainCode) error {
	return errors.WithStack(&DomainCodeError{
		code: code,
		msg:  domainCodeMessages[code],
	})
}

func NewDomainCodeErrorf(code DomainCode, format string, args ...any) error {
	return errors.WithStack(&DomainCodeError{
		code: code,
		msg:  fmt.Sprintf(domainCodeMessages[code]+" "+format, args...),
	})
}

func NewDomainCodeErrorWrap(code DomainCode, cause error) error {
	if cause == nil {
		return nil
	}
	return errors.WithStack(&DomainCodeError{
		code: code,
		msg:  fmt.Sprintf(domainCodeMessages[code]+" [cause: %+v]", cause),
	})
}

func NewDomainCodeErrorWrapf(code DomainCode, cause error, format string, args ...any) error {
	if cause == nil {
		return nil
	}
	return errors.WithStack(&DomainCodeError{
		code: code,
		msg: fmt.Sprintf(
			domainCodeMessages[code]+" [cause: %+v] "+format,
			append([]any{cause}, args...)...,
		),
	})
}

type DomainCodeError struct {
	code DomainCode
	msg  string
}

func (e *DomainCodeError) Error() string {
	return e.msg
}

func (e *DomainCodeError) Code() DomainCode {
	return e.code
}

func (e *DomainCodeError) Is(err error) bool {
	var target *DomainCodeError
	return errors.As(err, &target) && target.code == e.code
}
